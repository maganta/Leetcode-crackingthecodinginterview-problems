/**Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7] */






/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        
        if(inorder.length==0 || preorder.length==0 || inorder.length!=preorder.length){
            return null;
        }
        TreeNode root = new TreeNode(preorder[0]);
        
        Stack<TreeNode> s = new Stack<>();
        s.push(root);
        
        
        
        for(int p=1, i=0; ; ){
            if(s.peek().val != inorder[i]){
                TreeNode left = new TreeNode(preorder[p++]);
                s.peek().left = left;
                s.push(left);
            }else{
                ++i;
                if(i>=inorder.length){
                    break;
                }
                TreeNode currRoot = s.pop();
                if(!s.isEmpty() && s.peek().val==inorder[i]){
                    continue;
                }
                TreeNode right = new TreeNode(preorder[p++]);
                currRoot.right = right;
                s.push(right);
            }
        }
        
        return root;
        
    }
}
